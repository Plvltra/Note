### 1.
- 黑客(hacker): 本书中指优秀的程序员

### 2.黑客与画家
- 赚钱的软件往往不是好玩的软件,两者的重叠度不高。如果你想赚钱，你可能不得不去干那些很麻烦很讨厌的事情, 因为这些事情没人愿意义务来干。
- 价格是由供给和需求共同决定的。好玩的软件的需求量，比不上解决客户麻烦问题的软件的需求量。开发编程语言的收入，比不上把某些公司老掉牙的数据库连上服务器的收入。
- 黑客如何才能做自己喜欢的事情？解决方法是：**找一份养家糊口的“白天工作”**。更一般地说， “白天工作”的意思是,你有一份为了赚钱的工作,还有一份为了爱好的工作。
<br>

- 画家的作品都会保留下来，你观察这些作品，就能看出他们是怎么一步步通过实践学习绘画的。如果你把一个画家的作品按照时间顺序排列，就会发现每幅画所用的技巧，都是建立在上一幅作品学到的东西之上。某幅作品如果有特别出色之处,你往往能够在更早的作品上发现一个小规模的初期版本。
- 我想大多数创作者都是这样学习和工作的，作家和建筑师似乎都是如此。也许对于黑客来说,采取像画家这样的做法很有好处: **应该定期地从头开始，而不要长年累月地在一个项目上不断工作,并且试图把所有的最新想法都以修订版的形式包括进去**。
- 创作者的一个学习的途径是**通过范例**。对画家来说，博物馆就是美术技巧的图书馆。几百年来，**临摹大师的作品一直是传统美术教育的一部分**，因为临摹迫使你仔细观察一幅画是如何完成的。
- 如果黑客只是一个负责实现领导意志的技术工人，职责就是根据规格说明书写出代码，那么他其实与一个挖水沟的工人是一样的，从这头挖到那头,仅此而已。但是,如果黑客是一个创作者,他从事的就不是机械性的工作,他必须具备灵感。
- **程序写出来是给人看的，附带能在机器上运行**。软件的部分功能就是解释自身。
<br>

- 1430年到1500年之间的绘画杰作,至今仍然是不可超越的。一种新的媒介刚刚诞生的时候，人们热情高涨、兴奋不已，短短几代人就探索清楚了这种媒介的大部分可能性，把它的能量发挥到极致。编程目前好像就处在这个阶段。


### 3.不能说的话
- 在科学领域,质疑他人的结论和公认的假设是尤其重要的一件事,会提供巨大的科学创造的优势。科学家做事的方式,准确地说,就是寻找传统观点无法自圆其说的地方,然后试着拆开那里,看个究竟，瞧瞧里面到底出了什么问题，新的理论就是这样产生的。训练自己去想那些不能想的事情,你获得的好处会超过所得到的想法本身。
- 如果你的思想很保守,你自己不会知道,而且你很可果能还会持有相反的看法。

### 5. 另一条路
- 苹果公司的 Mac 电脑自从一问世，就在黑客之中很流行，许多黑客为它写软件。你在Windows 身上就很少看到这种现象，因为黑客不喜欢使用Windows。现在,善于写软件的那类人更喜欢使用Linux 或者 FreeBSD 操作系统。

### 6. 如何创造财富
- 创造有价值的东西就是创造财富，财富是最基本的东西。我们需要的东西就是财富，食品、服装、住房、汽车、生活用品、外出旅行等都是财富。要是你身处南极洲内陆,再多的钱对你也是无用的,因为没有东西可买,你真正需要的是财富。
- 我们这个世界,你向下沉沦或者向上奋进都取决于你自己,不能把原因推给外界。许许多多不创造任何财富的人，一听到最富有的5%人口占有全社会一半以上的财富，往往会认定这是不公平的。一个有经验的程序员很可能也认为这是不公平的。因为最顶尖的5%的程序员写出了全世界99%的优秀软件。
- 一个优秀程序员连续工作几个星期可能可以创造价值100万美元的财富。同样的时间内,一个平庸的程序员不仅无法创造财富,甚至还可能减少财富（比如引入了bug）。
<br>

- 当张三从学校毕业后,他应该要找工作。找工作其实就是加入另一个组织。表面上,这个组织与大学很相像。你先挑选想去的公司,然后向它递交申请。如果它觉得你不错,你就能加入了。你早上起床,来到一个新的地点,也是几幢建筑物,开始做你正常情况下没兴趣做的事情。仅有的区别就是,上班的日子不如上学的日子有趣,但是有人付钱给你,而不是你付钱给学校。但是,上学和上班的相似之处要大于它们的不同。张三, 20岁,某某大学的学生,现在变成了,张三, 22岁,某某公司的程序员。
- 一个大学毕业生总是想“我需要一份工作”,别人也是这么对他说的,好像变成某个组织的成员是一件多么重要的事情。更直接的表达方式应该是“你需要去做一些人们需要的东西”。即使不加入公司,你也能做到。
- 公司不过是一群人在一起工作,共同做出某种人们需要的东西。真正重要的是做出人们需要的东西，而不是加入某个公司。
- **许多人20岁出头时感到非常困惑和压抑。大学生活很有趣，可是已经过去了，上班的日子为什么会差别这么大？不要搞糊涂了，你现在已经从顾客变成了仆人。在这种新生活中获得乐趣是可能的。不过，你首先需要入门，门口的牌子写着“闲人勿进”。这种转变是一种冲击，如果你不赶快意识到这一点，事情将变得更糟。**
<br>

- 大公司会使得每个员工的贡献平均化。在大公司中,你只要一般性地努力工作,就能得到意料之中的薪水。你不能明显无能或懒惰,但是谁也没觉得你会把全部精力投入工作。销售员是单独工作的，大多数雇员则是集体工作。
<br>

- 要致富,你需要两样东西: **可测量性和可放大性**。你的职位产生的业绩,应该是可测量的,否则你做得再多,也不会得到更多的报酬。此外,你还必须有可放大性,也就是说你做出的决定能够产生巨大的效应。
- 单单具备可测量性是不够的。比如, 血汗工厂的工人报酬是按照计件制计算的,这是一个只有可测量性、没有可放大性的例子。你的表现可以被测量，并且据此得到回报，但是你没有决策的权力。你能做的唯一决策就是以多快的速度完成工作。即使你做到最快,回报可能也只增加一到二倍。CEO是一种同时具备可测量性和可放大性的工作。公司的表现就是CEO 的表现，所以它具备可测量性。CEO 的决策决定了整个公司的方向,所以它具备可放大性。
- 有一个办法可以发现是否存在可放大性，那就是看失败的可能性。因为收入和风险是对称的，所以如果有巨大的获利可能,就必然存在巨大的失败可能。CEO、电影明星、基金经理的头顶都悬着一把宝剑，随时可能掉下来。一旦他们搞砸了,他们就完了。如果你有一个令你感到安全的工作，你是不会致富的, 因为没有危险,就几乎等于没有可放大性。
- **小团体 = 可测量性**。大公司就像巨型的古罗马战舰，一千个划船手共同划桨，推动它前进。但是,两个因素使得它快不起来。一个因素是,每个划船手看不到自己更努力划桨有何不同;另一个因素是,一千人的团队使得任何个人的努力都被大大地平均化了。乔布斯曾经说过，创业的成败取决于最早加入公司的那十个人。小团虽队的优势不在于它本身的小, 而在于你可以选择成员。我们不需要小村庄的那种“小”，而需要全明星第一阵容的那种“小”。
- **高科技 = 可放大性**。创业公司通过发明新技术盈利，所以具备可放大性。什么是技术?技术就是某种手段,就是我们做事的方式。如果你发现了一种做事的新方式,它的经济价值就取决于有多少人使用这种新方式。技术就是钓鱼的鱼竿，而不是那条鱼。这就是创业公司与餐馆或理发店的区别。餐馆煎鸡蛋，理发店剪头发，每次只能为一个顾客提供服务，但是如果你解决了一个热门的技术难题，别人都会使用你的解决方案。这就是可放大性。
- 小团队天生就适合解决技术难题。技术的发展是非常快的,今天很有价值的技术，几年后可能就会丧失价值。小团队在如今这个时代可谓如鱼得水，因为他们不受官僚主义和繁琐管理制度的拖累。大公司也能开发出新技术，就是开发得比较慢而已。大公司的规模决定了它们无法快速行动,也无法测量并奖励表现优异的员工。所以在现实中,大公司开发出来的新技术只出现在那些需要大规模资本投入的领域，比如微处理器、电厂、大型民用飞机等，因为在这些领域内创业公司没有能力与之竞争。不过,即使在这些领域,大公司还是依仗创业公司提供零部件和构思。
<br>

- 事实上，买家假定用户知道谁有最好的技术。虽然这听上去很蠢，但是用户是你证明自己创造了财富的唯一证据。财富就是人们需要的东西,如果没人使用你的软件,可能不是因为你的推广活动很失败,而是因为你没有做出人们需要的东西。风险投资商有一张清单,上面写满了各种表示不应该收购的危险信号。排在榜首的信号中有一个就是公司由技术顽童掌控,只想解决有趣的技术问题,不考虑用户的需要。你开办创业公司不是单纯地为了解决虑问题，而是为了解决那些**用户关心的问题**。

### 7. 关注贫富分化
- 如果得不到报酬，人们是否愿意创造财富？唯一的可能就是，工作必须能提供乐趣。会有人愿意免费写一个操作系统,但是他们不愿意免费为你安装、提供电话支持、进行客户培训等。即使是最先进的高科技公司，也有至少 90%的工作没有乐趣、令人生厌。

### 9. 设计者的品味
- 好设计是简单的设计
- 好设计是永不过时的设计
- 好设计是解决主要问题的设计。答案可以不断改进,同样, 问题本身也可以不断改进。软件的难题通常可以被改成等价的较易解决的形式。
- 好设计是启发性的设计。在软件业中，这条原则意味着，你应该为用户提供一些基本模块，使得他们可以随心所欲自由组合，就像玩乐高积木那样。在数学中，这条原则意味着，一个可以成为许多新工作基础的证明要优于一个难度很高、但无助于未来学科发展的证明。
- 好设计通常是有点趣味性的设计。这是因为幽默一定程度上反映了力量。幽默感是强壮的一种表现，始终拥有幽默感就代表你对厄运一笑了之，而丧失幽默感则表示你被厄运深深伤到。所以,强壮的标志（或者至少是特点)就是轻松面对自己的人生。
- 好设计是艰苦的设计。当解决难题成为压倒一切的任务时,那些流行样式与华丽装饰就被抛到一边去了。并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前冲刺的痛苦,而不是脚被钉子扎破的痛苦。解决难题的痛苦对设计师有好处,但是对付挑剔的客户的痛苦或者对付质量低劣的建材的痛苦就是另外一回事了。
- 好设计是看似容易的设计。科学和工程学的一些最重大的发现在形式上往往很简单,会使得你觉得自己也想到过。可是，如果它真的那么简单，为什么发现人不是你呢？在大多数领域，看上去容易的事情，背后都需要大量的练习。练习的作用也许是训练你把刻意为之的事情变成一种自觉的行为。
- 好设计是对称的设计。对称也许只是简洁性的一种表现，但是它十分重要，值得单独列为一点。自然界的对称大量存在，这就说明了对称的重要性。**对称有两种:重复性对称和递归性对称。递归性对称就是指子元素的重复，比如树叶上叶脉的纹路**。
- 好设计是模仿大自然的设计。我不是说模仿大自然这种行为本身有多么好,而是说大自然在长期的演化中已经解决了很多设计问题。所以,如果你的设计与大自然很接近，那么它基本上不会很差。
- 好设计是一种再设计。很少有人一次就把事情做对。专家的做法是先完成一个早期原型,然后提出修改计划,最后把早期原型扔掉。
- 好设计是能够给复制的设计。我们对待复制的态度经常是一个否定之否定的过程。刚入门的新手不知不觉地模仿他人,逐渐熟练之后才开始创作原创性作品。最后他会意识到，把事情做对比原创更重要。
- 不知不觉的模仿几乎必然将导致坏设计。如果你不知道自己的想法从何而来，那么你可能就是在模仿另一个模仿者。等到你逐渐对一件事产生热情的时候,就不会满足于模仿了。你的品味就进入了第二阶段, 开始自觉地进行原创。
- 好设计常常是奇特的设计。
- 好设计师成批出现的。15 世纪住在佛罗伦萨的伟大艺术家众多，米兰也是同等的大城市，请问你能说出15世纪米兰城有什么伟大艺术家吗？**推动人才成批涌现的最大因素就是,让有天赋的人聚在一起,共同解决某个难题**。互相激励比天赋更重要，达·芬奇之所以成为达·芬奇，主要原因不仅仅是他的天赋,更重要的是他生活在当时的佛罗伦萨。在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出伟大的成绩。如果你远离这些中心,几乎不可能单靠自己就取得伟大成果。
- 好设计常常是大胆的设计。发现丑陋的东西要比你想象出一个优美的东西更容易。大多数做出优美成果的人好像只是为了修正他们眼中丑陋的东西。伟大成果的出现常常来源于某人看到一样东西后，心想我能做得比这更好。单单是无法容忍丑陋的东西还不够，只有对这个领域非常熟悉，你才可能发现哪些地方可以动手改进。优秀作品的秘诀就是:非常严格的品味,再加上实现这种品味的能力。

### 11. 一百年后的编程语言
- 我认为，基本运算符是一种语言能否长期存在的最重要因素。任何一种编程语言都可以分成两大组成部分:基本运算符的集合(扮演公理的角色）以及除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来）。其他因素都不是决定性的。这有点像买房子的时候你应该先考虑地理位置。别的地方将来出问题都有办法弥补,但是地理位置是没法变的。慎重选择公理还不够,还必须控制它的规模。我的判断是，那些**内核最小、最干净的编程语言**才会存在于进化的主干上。一种语言的内核设计得越小、越干净,它的生命力就越顽强。
- 编程语言进化缓慢的原因在于它们并不是真正的技术。语言只是一种书写法,而程序则是一种严格符合规则的描述,以书面形式记录计算机应该如何解决你的问题。所以,编程语言的进化速度更像数学符号的进化速度，而不像真正的技术（比如交通或通信技术）的进化速度。数学符号的进化是缓慢的渐变式变化,而不是真正技术的那种跳跃式发展。

- Lisp 语言的黑客早就明白数据结构灵活性的价值。我们写程序的第一版时,往往会把所有事情都用列表的形式处理。所以,这些最初版本可能效率低下得惊人,你必须努力克制自己才能忍住不动手优化它们。
- 一百年后的程序员最需要的编程语言就是可以让你毫不费力地写出程序第一版的编程语言,哪怕它的效率低下得惊人(至少按我们今天的眼光来看是如此)。他们会说,他们想要的就是很容易上手的编程语言。
- 效率低下的软件并不等于很烂的软件。**一种让程序员做无用功的语言才真正称得上很烂**。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。随着计算机速度越来越快,这会变得越来越明显。

### 12. 拒绝平庸
- 大家都知道，徒手用机器语言写出整个程序是一件很蠢的事。但是，把这个观点推广到一种更普遍的情况,知道的人就不多了。如果你有好几种语言可以选择，在**不考虑其他因素的情况下，你不选择最强大的那种语言就是一件很蠢的事**。
- 技术的变化速度通常是很快的。但是，编程语言不一样，与其说它是技术,还不如说是程序员的思考模式。编程语言是技术和宗教的混合物。所以,一种很普通的编程语言就是很普通的程序员使用的语言,它的变化就像冰山那样缓慢。
<br>

- 如果你为创业公司工作，那么这里有一个评估竞争对手的妙招——关注他们的招聘职位。他们网站上的其他内容无非是一些陈腐的照片和夸夸其谈的文字，但是**招聘职位却不得不写得很明确，反映出他们到底想干什么**，否则就会引来一大批不合适的求职者。
- 有些公司的职位描述使用了大量的IT词汇,这样的内容越多,这家公司就越不构成威胁。最不用担心的竞争对手就是那些要求应聘者具有Oracle数据库经验的公司,你永远不必担心他们。如果他们招聘 Perl 或 Python 程序员，就稍微有点威胁了。至少这听起来像一家技术公司,并且由黑客控制。如果我有幸见到一家招聘 Lisp 黑客的公司,就会真的感到如临大敌。

### 13. 书呆子的复仇
- Lisp和Fortran代表了编程语言发展的两大方向。**前者的基础是数学,后者的基础是硬件架构**。从那时起,这两大方向一直在互相靠拢。Lisp语言刚设计出来的时候就很强大,接下来的二十年它提高了运行速度。而那些所谓的主流语言把更快的运行速度作为设计的出发点,然后再一步步变得更强大。
- 强大的编程语言如何让你写出更短的程序？一个技巧就是（在语言允许的前提下）使用“自下而上”（bottom-up）的编程方法。你**不是用基础语言（base language）开发应用程序，而是在基础语言之上先构建一种你自己的语言,然后再用后者开发应用程序**。这样写出来的代码会比直接用基础语言开发出来的短得多。实际上,大多数压缩算法也是这样运作的。“自下而上”的编程往往也便于修改，因为许多时候你自己添加的中间层根本不需要变化，你只需要修改前端逻辑就可以了。ITA 软件公司的文章说“1 行 Lisp代码相当于 20 行 C 代码”。
<br>

- 我们有了两点结论，事实上，这是我用自己的经历换来的。第一,**不同语言的编程能力不一样**。第二,大多数经理故意忽视第一点。

### 14. 梦寐以求的编程语言
- **可编程性**(Hackability) 我认为，语言设计者应该假定他们的目标用户是一个天才,会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。你也许能够阻止他引用另一个模块中的变量，但是你**没法防止他日日夜夜不知疲倦地写出结构混乱的程序去解决完全错误的问题**。
- 优秀程序员经常想做一些既危险又令人恼火的事情。我指的是他们会突破设计者提供给用户的外部语义层,试着控制某些高级抽象的语言内部接口。比如，黑客喜欢破解，而破解就意味着深入内部,揣测原始设计者的意图。
- 一种编程语言必须善于完成黑客想要完成的各种任务。这意味着它必须很适合开发一次性程序。比如,自动完成某些系统管理任务的程序,或者自动生成测试数据的程序,以及在不同格式之间转化数据的程序等。令人吃惊的是,一次性程序往往不是真的只用一次,就像二战期间很多美国大学造的一大批临时建筑后来都成了永久建筑。我有一种预感，最优秀的那些大型程序就是这样发展起来的，
- 设计优秀的函数库是很难的，一旦函数库数量变得太多，找到一个你需要的函数有时候还不如自己动手写来得快。函数库的设计基础与语言内核一样，都是一个**小规模的正交运算符集合**。
<br>

- **帕金森定律**（Parkinson's Law）: 一种原始表达形式是“工作总是到最后一刻才会完成”，后来引申到计算机领域就变成了“数据总是会填满所有空间”，更一般性的总结则是“**对一种资源的需求总是会消耗光这种资源的所有供应**”，软件不断膨胀,消耗光所有可以得到的资源。
- 为了写出优秀软件，你必须同时具备两种互相冲突的信念。一方面，你要对自己的能力信心万丈；另一方面，你又要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。这里的难点在于你要意识到，实际上这两种信念并不矛盾。你的乐观主义和怀疑倾向分别针对两个不同的对象。你必须**对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑**。

### 15. 设计与研究
- 设计与研究的区别看来就在于，**前者追求“好”(good)**，**后者追求“新”(new)**。优秀的设计不一定很“新”,但必须是“好”的;优秀的研究不一定很“好”，但必须是“新”的。我认为这两条道路最后会发生交叉：只有应用“新”的创意和理论，才会诞生超越前人的最佳设计；只有解决那些值得解决的难题（也就是“好”的难题），才会诞生最佳研究。所以,最终来说，设计和研究都通向同一个地方,只是前进的路线不同罢了。
- 除非设定目标用户，否则一种设计的好坏根本无从谈起。如果目标用户群体涵盖了设计师本人，那么最有可能诞生优秀设计。如果目标用户与你本人差别很大，你往往会假定目标用户的需求比你本人的需求更简单，而不是更复杂。
- **怎么理解编程语言**？你不要把它看成那些**已完成的程序的表达方式**，而应该把它理解成**促进程序从无到有的一种媒介**。这里的意思是说，成品的材料和开发时用的材料其实是不一样的。搞艺术的人都知道，这两个阶段往往需要不同的媒介。比如，大理石是一种非常良好、耐用的材料,很适合用于最后的成品,但是它极其缺乏弹性和灵活性,所以不适合在构思阶段用来做模型。最后写出来的程序就像已经完成的数学证明一样,是一棵经过精心修剪的树木，上面杂乱滋生的树杈都已经被剪去了。所以，评价一种语言的优劣不能简单地看最后的程序是否表达得很漂亮,而要看**程序从无到有的那条完成路径是否很漂亮**。
- 在软件领域，贴近用户的设计思想被归纳为“弱即是强”(Worse isBetter)，其中有一点是正确的,那就是**如果你正在设计某种新东西,就应该尽快拿出原型,听取用户的意见**。与之对照，还有另一种软件设计思想，也许可以被称为“万福玛丽亚”模式。它不要求尽快拿出原型,然后再逐步优化,它的观点是你应该等到完整的成品出来以后再一下子隆重地推向市场,我还没听说过有人采用这种模式而获得成功。几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。
<br>

- **士气是设计的关键因素**。我的一位美术启蒙老师告诉我:**如果你觉得画某样东西很乏味,那么你画出来的东西就会真的很乏味**。比如,**假设你必须画一幢建筑物,你决定从每一块砖头开始画起。你觉得自己可以坚持下去,但是画到一半的时候突然感到很厌倦,于是你就不再认真观察每块砖头并画出它们各自不同的特点,而是以一种机械重复的方式草草地把砖头画完了事**。这样一来,你的作品效果就很差,甚至还不如一开始就不采用写实手法,只是若隐若现地暗示砖头的存在。
- **先做出原型，再逐步加工做出成品，这种方式有利于鼓舞士气**，因为它使得你随时都可以看到工作的成效。开发软件的时候，我有一条规则：**任何时候，代码都必须能够运行。如果你正在写的代码一个小时之后就可以看到运行结果**。这好比让你看到不远处就是唾手可得的奖励,你因此会受到激励和鼓舞。其他艺术领域也是如此，大多数画家都是先画一个草图，然后再逐步加工。你每天收工的时候都可以看到整体的效果,不会对最后的成品一点感觉都没有。
- **士气也可以解释为什么很难为低端用户设计出优秀产品**。因为优秀设计的前提是你自己必须喜欢这种产品，否则你不可能对设计有兴趣，更不要说士气高昂了。为了把产品设计好,你必须对自己说:“哇,这个产品太棒了,我一定要设计好!”而不是心想: “这种垃圾玩意,只有傻瓜才会喜欢，随便设计一下就行了。”